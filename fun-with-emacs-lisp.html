<!DOCTYPE html>
<html lang="en">
  <head>
          <img  class = "profile" width = "100" height = "100"  src = /static/misc/avatar_jjp.jpg>
      <title>James J Porter</title>
      <link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,600italic,700italic,400,600,700' rel='stylesheet' type='text/css' />
      <link href='http://fonts.googleapis.com/css?family=Cherry+Swash:400,700' rel='stylesheet' type='text/css' />
      <link href='http://fonts.googleapis.com/css?family=Libre+Baskerville:700' rel='stylesheet' type='text/css'>
      <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:200,400,700' rel='stylesheet' type='text/css'>
      <link rel="stylesheet" type="text/css" href="./theme/css/styles.css" />
      <link rel="stylesheet" href="/theme/css/icons.css">
      <meta charset="utf-8" />
              <link href="http://jamesjporter.me/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="James J Porter Full Atom Feed" />
                              </head>

  <body id="index" class="home">
    <header id="banner" class="body">
      <h1 class="sitetitle"><a href=".">James J Porter</a></h1>
      <h3 class ="sitesubtitle">"Turns out I am a simple man, at best."</h3>
    </header><!-- /#banner -->
    <nav id="menu"><ul>
                  <li><a href="/">blog</a></li>
                  <li><a href="/static/misc/cv.pdf">cv</a></li>
                                      <li><a href="./pages/about.html">about</a></li>
                  	<li><a class="icon-mail-alt" href="mailto:porterjamesj@gmail.com"></a><li>
	<li><a class="icon-github" href="https://github.com/porterjamesj"></a><li>
	<li><a class="icon-stackoverflow" href="http://stackoverflow.com/users/1663558/james-porter"></a><li>
    </ul></nav>
    <section id="content" class="body">
  <header>
    <h1 class="entry-title">
      <a href="fun-with-emacs-lisp.html" rel="bookmark"
         title="Permalink to Fun with EmacsÂ Lisp">Fun with Emacs&nbsp;Lisp</a></h1>
  
  </header>
  <div class="post-info">
    <abbr class="published" title="2013-06-14T00:00:00">
      Fri 14 June 2013
    </abbr>
      </div><!-- /.post-info -->
  <div class="entry-content">
    <p>An interseting thing about the world or modern programming is that many decisions have already been made for us. For example, what the the following code snippets&nbsp;do?</p>
<p>Python:</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">fun1</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>

<span class="n">fun1</span><span class="p">()(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>


<p>Javascript:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">fun1</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span><span class="o">*</span><span class="nx">y</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="nx">fun1</span><span class="p">()(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>


<p>The answer is, they print 36. But what about the equivalent code in Emacs&nbsp;lisp?:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="nf">funcall</span> <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">12</span><span class="p">))</span>
           <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>


<p>This throws an error: <code>(void-variable x)</code>. Huh? What is going on? The answer is that most modern languages, including python and javascript, are lexically scoped, whereas emacs lisp, being many decades old, is dynamically scoped. What does this mean? It has to do with the resolution of free variables. In each code example above, <code>x</code> is a free variable in the innermost function call because it is not passed as an argument and has no local definition. How is the definition of a free variable resolved then? In lexically scoped languages, the language looks for definitions of free variables in the immediate <em>lexical environment</em>, whereas in dynamically scoped langauges, the language looks for definitions of free variables in the immediate <em>evaluating environment</em>. </p>
<p>This explains our differing results above. Python and javascript see a free variable <code>x</code> in the definition of <code>fun2</code>. They go look for a definition in the enclosing lexical scope (the definition of <code>fun1</code>), see that here x is defined to be 12, and use 12 as the value for x. Emacs lisp, on other hand, does the following. Using <code>funcall</code>, we asked it to call the following with argument <code>3</code>:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">12</span><span class="p">))</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
</pre></div>


<p>The <code>let</code> statement says that during the evaluation of the following code, let the value of <code>x</code> be 12. The keyword here is <em>evaluation</em>. Emacs lisp allows <code>x</code> to be 12 during the evaluation, which returns a function of <code>y</code>. The evaluation is then over, so emacs lisp promptly forgets the value of <code>x</code>! The lambda function returned has no notion of the fact that <code>x</code> is twelve in its lexical environment; when this function is called by <code>funcall</code> it is called in the global scope, in which there is no definition of <code>x</code>, hence <code>(void-variable x)</code>.</p>
<p>This seems weird by modern lights, because most languages we write code in regularly are lexically scoped. Emacs lisp gets ever weirder though. Remember when I said that python and javascript &#8220;go look for a definition in the enclosing lexical scope&#8221;? That was sort of a lie. They don&#8217;t really go looking through the text of your code trying to find definitions, what actually happens is that when <code>fun1</code> evaluates, it doesn&#8217;t just return a bare function, it returns a <em>closure</em>, which is a data structure that includes the inner function <em>along with the definitions of the variables in its lexical environment</em>. When python or javascript needs to know the value of <code>x</code> during evaluation, they go look up its definition in the closure. You can&#8217;t actually examine closures in the language itself; they&#8217;re special and hidden away in the implementation. But let&#8217;s go back to Elisp for a moment. When we&nbsp;execute</p>
<div class="codehilite"><pre><span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">12</span><span class="p">))</span>
         <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
</pre></div>


<p>We get&nbsp;back:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre></div>


<p>which is a function definition, pretty much what we expected. Notice that this expression evluated on its own (which is effectively what we were doing when we did the <code>funcall</code> above) hs no way of figuring out what <code>x</code> is (i.e. no closure containing a definition of <code>x</code>). Where Emacs lisp gets weird is that it is possible to have lexical scoping, but its an optional feature that you have to turn on. Let&#8217;s try&nbsp;it:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="nf">setq</span> <span class="nv">lexical-binding</span> <span class="nv">t</span><span class="p">)</span>

<span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">12</span><span class="p">))</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
</pre></div>


<p>Now the second expression evaluates&nbsp;to:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="nf">closure</span> <span class="p">((</span><span class="nf">x</span> <span class="o">.</span> <span class="mi">12</span><span class="p">)</span> <span class="nv">t</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre></div>


<p>Aha! A closure! Because lexical scope was tacked onto Elisp decades after its creation, it doesn&#8217;t hide closures away from you the way more modern languages do; they are right there, available to be inspected as data structures in the language itself. If we funcall this with 3 as an argument, we get 36, just like we did in python or javascript. Internally, they are doing the same thing with the closure, we as programmers are just not allowed to see it. Emacs lisp is adorably trusting; however, which means we can do stupidly silly things. The closure is just a list, so we can use it as we would any&nbsp;other:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="nf">setq</span> <span class="nv">cl</span> <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">x</span> <span class="mi">12</span><span class="p">))</span>
           <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">y</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>
</pre></div>


<p>The closure is now bound to the symbol <code>cl</code>, and we can funcall&nbsp;it:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="nf">funcall</span> <span class="nv">cl</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;; =&gt; 36</span>
</pre></div>


<p>We can also modify it,&nbsp;e.g.:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="nf">setcdr</span> <span class="p">(</span><span class="nb">caadr </span><span class="nv">cl</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>


<p>We set the <code>cdr</code> of the <code>car</code> of the <code>car</code> of the <code>cdr</code> of <code>cl</code> to 5. This changes cl&nbsp;to:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="nf">closure</span> <span class="p">((</span><span class="nf">x</span> <span class="o">.</span> <span class="mi">5</span><span class="p">)</span> <span class="nv">t</span><span class="p">)</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre></div>


<p>And&nbsp;now:</p>
<div class="codehilite"><pre><span class="p">(</span><span class="nf">funcall</span> <span class="nv">cl</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;; =&gt; 15</span>
</pre></div>


<p>This is hilarious, but as Gary Bernhardt said, <a href="https://www.youtube.com/watch?v=kXEgk1Hdze0">if you ever actually do this then wat</a>.</p>
  </div><!-- /.entry-content -->
</section>
    <footer id="contentinfo" class="body">
      <p>All content Â© 2013 James Porter, license <a href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution ShareAlike</a> unless otherwise noted. Generated by <a href= "http://docs.getpelican.com/">Pelican</a>.</p>
    </footer>
  </body>
</html>